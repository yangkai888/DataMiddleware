# 安全设计规范

## 概述

数据中间件的安全设计涵盖传输安全、数据安全、访问控制和安全监控四个层面，确保系统在高并发场景下的安全性。

## 传输安全

### TLS加密配置

#### TCP传输加密
```go
// TLS配置
tlsConfig := &tls.Config{
    MinVersion:               tls.VersionTLS12,
    MaxVersion:               tls.VersionTLS13,
    CipherSuites:             []uint16{
        tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
        tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
    },
    PreferServerCipherSuites: true,
    SessionTicketsDisabled:   false,
    ClientAuth:               tls.RequireAndVerifyClientCert, // 双向认证
    Certificates:             []tls.Certificate{serverCert},
    ClientCAs:                caCertPool,
    InsecureSkipVerify:       false, // 生产环境必须false
}

// 应用TLS配置
listener, err := tls.Listen("tcp", ":9090", tlsConfig)
```

#### HTTP传输加密
```go
// HTTPS服务器配置
server := &http.Server{
    Addr: ":8443",
    TLSConfig: &tls.Config{
        MinVersion: tls.VersionTLS12,
        MaxVersion: tls.VersionTLS13,
        CipherSuites: []uint16{
            tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
            tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,
        },
        Certificates: []tls.Certificate{serverCert},
        ClientAuth:   tls.RequestClientCert, // 可选客户端证书
    },
    Handler: router,
}

// 启动HTTPS服务器
server.ListenAndServeTLS("server.crt", "server.key")
```

### 证书管理

#### 证书轮换策略
```go
type CertificateManager struct {
    certMu   sync.RWMutex
    cert     *tls.Certificate
    certPath string
    keyPath  string
}

func (cm *CertificateManager) LoadCertificate() error {
    cert, err := tls.LoadX509KeyPair(cm.certPath, cm.keyPath)
    if err != nil {
        return err
    }

    cm.certMu.Lock()
    cm.cert = &cert
    cm.certMu.Unlock()

    return nil
}

func (cm *CertificateManager) GetCertificate() *tls.Certificate {
    cm.certMu.RLock()
    defer cm.certMu.RUnlock()
    return cm.cert
}

// 定期检查证书更新
func (cm *CertificateManager) WatchCertificateChanges() {
    ticker := time.NewTicker(24 * time.Hour)
    for range ticker.C {
        if cm.isCertificateExpired() {
            cm.LoadCertificate()
        }
    }
}
```

#### ACME自动证书
```go
import "github.com/go-acme/lego/v4"

// Let's Encrypt自动证书
client, err := lego.NewClient(lego.NewConfig(&account))
if err != nil {
    return err
}

// 申请证书
certificates, err := client.Certificate.Obtain(certificate.ObtainRequest{
    Domains: []string{"api.example.com"},
    Bundle:  true,
})
if err != nil {
    return err
}
```

## 数据安全

### 敏感数据加密

#### 字段级加密
```go
import "crypto/aes"
import "crypto/cipher"

type FieldEncryptor struct {
    key []byte
    gcm cipher.AEAD
}

func (fe *FieldEncryptor) Encrypt(plaintext string) (string, error) {
    nonce := make([]byte, fe.gcm.NonceSize())
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        return "", err
    }

    ciphertext := fe.gcm.Seal(nonce, nonce, []byte(plaintext), nil)
    return base64.StdEncoding.EncodeToString(ciphertext), nil
}

func (fe *FieldEncryptor) Decrypt(ciphertext string) (string, error) {
    data, err := base64.StdEncoding.DecodeString(ciphertext)
    if err != nil {
        return "", err
    }

    nonceSize := fe.gcm.NonceSize()
    if len(data) < nonceSize {
        return "", errors.New("ciphertext too short")
    }

    nonce, ciphertext := data[:nonceSize], data[nonceSize:]
    plaintext, err := fe.gcm.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        return "", err
    }

    return string(plaintext), nil
}
```

#### 数据库字段加密
```sql
-- 创建加密函数
DELIMITER //
CREATE FUNCTION encrypt_field(data VARCHAR(255), key_id INT)
RETURNS VARBINARY(255)
DETERMINISTIC
BEGIN
    DECLARE encrypted VARBINARY(255);
    -- 使用AES_ENCRYPT加密
    SET encrypted = AES_ENCRYPT(data, get_key_by_id(key_id));
    RETURN encrypted;
END //
DELIMITER ;

-- 创建解密函数
DELIMITER //
CREATE FUNCTION decrypt_field(encrypted VARBINARY(255), key_id INT)
RETURNS VARCHAR(255)
DETERMINISTIC
BEGIN
    DECLARE decrypted VARCHAR(255);
    SET decrypted = AES_DECRYPT(encrypted, get_key_by_id(key_id));
    RETURN decrypted;
END //
DELIMITER ;

-- 使用示例
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    email VARBINARY(255),  -- 加密存储
    phone VARBINARY(255),  -- 加密存储
    key_version INT DEFAULT 1
);

-- 插入数据时加密
INSERT INTO users (name, email, phone)
VALUES ('John', encrypt_field('john@example.com', 1), encrypt_field('1234567890', 1));

-- 查询时解密
SELECT name,
       decrypt_field(email, key_version) as email,
       decrypt_field(phone, key_version) as phone
FROM users;
```

### 密钥管理

#### 密钥轮换机制
```go
type KeyManager struct {
    currentKeyID string
    keys         map[string][]byte
    mu           sync.RWMutex
}

func (km *KeyManager) RotateKey() error {
    km.mu.Lock()
    defer km.mu.Unlock()

    // 生成新密钥
    newKey := make([]byte, 32)
    if _, err := rand.Read(newKey); err != nil {
        return err
    }

    // 更新当前密钥ID
    newKeyID := generateKeyID()
    km.keys[newKeyID] = newKey
    km.currentKeyID = newKeyID

    // 异步重新加密旧数据
    go km.reEncryptOldData()

    return nil
}

func (km *KeyManager) GetKey(keyID string) ([]byte, error) {
    km.mu.RLock()
    defer km.mu.RUnlock()

    key, exists := km.keys[keyID]
    if !exists {
        return nil, errors.New("key not found")
    }

    return key, nil
}
```

#### HSM集成 (硬件安全模块)
```go
import "crypto/hsm"

// HSM密钥管理
type HSMKeyManager struct {
    hsmClient *hsm.Client
}

func (hkm *HSMKeyManager) GenerateKey(keyType hsm.KeyType) (string, error) {
    keyID, err := hkm.hsmClient.GenerateKey(keyType, hsm.KeyUsageEncrypt|hsm.KeyUsageDecrypt)
    if err != nil {
        return "", err
    }

    return keyID, nil
}

func (hkm *HSMKeyManager) Encrypt(keyID string, plaintext []byte) ([]byte, error) {
    return hkm.hsmClient.Encrypt(keyID, plaintext, nil)
}

func (hkm *HSMKeyManager) Decrypt(keyID string, ciphertext []byte) ([]byte, error) {
    return hkm.hsmClient.Decrypt(keyID, ciphertext, nil)
}
```

## 访问控制

### JWT认证

#### JWT令牌管理
```go
import "github.com/golang-jwt/jwt/v5"

type JWTManager struct {
    secret     []byte
    issuer     string
    expireTime time.Duration
}

type Claims struct {
    UserID   int64    `json:"user_id"`
    Username string   `json:"username"`
    Roles    []string `json:"roles"`
    jwt.RegisteredClaims
}

func (jm *JWTManager) GenerateToken(userID int64, username string, roles []string) (string, error) {
    now := time.Now()
    claims := Claims{
        UserID:   userID,
        Username: username,
        Roles:    roles,
        RegisteredClaims: jwt.RegisteredClaims{
            Issuer:    jm.issuer,
            IssuedAt:  jwt.NewNumericDate(now),
            ExpiresAt: jwt.NewNumericDate(now.Add(jm.expireTime)),
            NotBefore: jwt.NewNumericDate(now),
        },
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(jm.secret)
}

func (jm *JWTManager) ValidateToken(tokenString string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, interface{}) {
        return jm.secret, nil
    })

    if err != nil {
        return nil, err
    }

    if claims, ok := token.Claims.(*Claims); ok && token.Valid {
        return claims, nil
    }

    return nil, errors.New("invalid token")
}
```

#### Token缓存和黑名单
```go
type TokenCache struct {
    validTokens   cache.Cache // 有效token缓存
    blacklistedTokens cache.Cache // 黑名单token缓存
}

func (tc *TokenCache) IsTokenValid(tokenID string) bool {
    // 检查黑名单
    if tc.blacklistedTokens.Get(tokenID) != nil {
        return false
    }

    // 检查有效性
    return tc.validTokens.Get(tokenID) != nil
}

func (tc *TokenCache) BlacklistToken(tokenID string, expireTime time.Duration) {
    tc.blacklistedTokens.Set(tokenID, true, expireTime)
    tc.validTokens.Delete(tokenID)
}
```

### 角色-based访问控制 (RBAC)

#### RBAC权限模型
```go
type RBACManager struct {
    roles        map[string]*Role
    permissions  map[string]*Permission
    userRoles    map[int64][]string
    rolePerms    map[string][]string
}

type Role struct {
    ID          string
    Name        string
    Description string
    Permissions []string
}

type Permission struct {
    ID          string
    Name        string
    Resource    string
    Action      string
    Description string
}

func (rbac *RBACManager) HasPermission(userID int64, resource, action string) bool {
    userRoles := rbac.userRoles[userID]

    for _, roleName := range userRoles {
        if rolePerms, exists := rbac.rolePerms[roleName]; exists {
            for _, permID := range rolePerms {
                if perm := rbac.permissions[permID]; perm != nil {
                    if perm.Resource == resource && perm.Action == action {
                        return true
                    }
                }
            }
        }
    }

    return false
}
```

#### 权限中间件
```go
func RBACMiddleware(rbac *RBACManager, resource, action string) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 从上下文获取用户信息
        userID, exists := c.Get("user_id")
        if !exists {
            c.AbortWithStatusJSON(401, gin.H{"error": "unauthorized"})
            return
        }

        // 检查权限
        if !rbac.HasPermission(userID.(int64), resource, action) {
            c.AbortWithStatusJSON(403, gin.H{"error": "forbidden"})
            return
        }

        c.Next()
    }
}

// 使用示例
router.GET("/api/users", RBACMiddleware(rbac, "user", "read"), userHandler.List)
router.POST("/api/users", RBACMiddleware(rbac, "user", "create"), userHandler.Create)
```

### 请求频率限制

#### 分布式限流
```go
import "github.com/go-redis/redis/v8"

type RateLimiter struct {
    redis   *redis.Client
    window  time.Duration
    limit   int
    keyFunc func(*gin.Context) string
}

func (rl *RateLimiter) Allow(c *gin.Context) bool {
    key := rl.keyFunc(c)

    // 使用Redis Lua脚本实现原子操作
    script := redis.NewScript(`
        local current = redis.call("GET", KEYS[1])
        if current then
            if tonumber(current) >= tonumber(ARGV[1]) then
                return 0
            end
            redis.call("INCR", KEYS[1])
        else
            redis.call("SETEX", KEYS[1], ARGV[2], 1)
        end
        return 1
    `)

    result, err := script.Run(c.Request.Context(), rl.redis,
        []string{key}, rl.limit, int(rl.window.Seconds())).Result()

    if err != nil {
        // 限流服务不可用时，允许请求通过
        return true
    }

    return result.(int64) == 1
}

// 限流中间件
func RateLimitMiddleware(limiter *RateLimiter) gin.HandlerFunc {
    return func(c *gin.Context) {
        if !limiter.Allow(c) {
            c.AbortWithStatusJSON(429, gin.H{
                "error": "too many requests",
                "retry_after": limiter.window.Seconds(),
            })
            return
        }

        c.Next()
    }
}
```

#### 自适应限流
```go
type AdaptiveRateLimiter struct {
    baseLimiter *RateLimiter
    cpuThreshold float64
    scaleFactor  float64
}

func (arl *AdaptiveRateLimiter) Allow(c *gin.Context) bool {
    // 获取当前CPU使用率
    cpuPercent := getCPUPercent()

    // 根据CPU使用率调整限流阈值
    if cpuPercent > arl.cpuThreshold {
        // CPU负载高，降低限流阈值
        adjustedLimit := int(float64(arl.baseLimiter.limit) * arl.scaleFactor)
        arl.baseLimiter.limit = adjustedLimit
    }

    return arl.baseLimiter.Allow(c)
}
```

## 安全监控

### 审计日志

#### 安全事件审计
```go
type AuditLogger struct {
    logger Logger
    queue  chan *AuditEvent
}

type AuditEvent struct {
    Timestamp   time.Time              `json:"timestamp"`
    UserID      int64                  `json:"user_id,omitempty"`
    Username    string                 `json:"username,omitempty"`
    Action      string                 `json:"action"`
    Resource    string                 `json:"resource"`
    ResourceID  string                 `json:"resource_id,omitempty"`
    IPAddress   string                 `json:"ip_address"`
    UserAgent   string                 `json:"user_agent,omitempty"`
    Success     bool                   `json:"success"`
    Details     map[string]interface{} `json:"details,omitempty"`
}

func (al *AuditLogger) Log(event *AuditEvent) {
    select {
    case al.queue <- event:
    default:
        // 队列满时，同步记录
        al.logger.Info("audit_event", zap.Any("event", event))
    }
}

func (al *AuditLogger) Start() {
    go func() {
        for event := range al.queue {
            al.logger.Info("audit_event", zap.Any("event", event))
        }
    }()
}
```

#### 审计中间件
```go
func AuditMiddleware(auditLogger *AuditLogger) gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()

        // 获取用户信息
        userID, _ := c.Get("user_id")
        username, _ := c.Get("username")

        c.Next()

        // 创建审计事件
        event := &AuditEvent{
            Timestamp:  start,
            UserID:     getInt64Value(userID),
            Username:   getStringValue(username),
            Action:     c.Request.Method,
            Resource:   c.Request.URL.Path,
            IPAddress:  c.ClientIP(),
            UserAgent:  c.Request.UserAgent(),
            Success:    c.Writer.Status() < 400,
            Details: map[string]interface{}{
                "status_code": c.Writer.Status(),
                "duration":    time.Since(start).Milliseconds(),
                "query":       c.Request.URL.RawQuery,
            },
        }

        auditLogger.Log(event)
    }
}
```

### 入侵检测

#### 异常行为检测
```go
type AnomalyDetector struct {
    requestPatterns map[string]*RequestPattern
    alertThreshold  int
    alertChan       chan *Alert
}

type RequestPattern struct {
    Path         string
    Method       string
    Count        int64
    LastSeen     time.Time
    BlockedUntil time.Time
}

func (ad *AnomalyDetector) CheckRequest(c *gin.Context) bool {
    key := c.Request.Method + ":" + c.Request.URL.Path
    ip := c.ClientIP()

    pattern := ad.requestPatterns[key]
    if pattern == nil {
        pattern = &RequestPattern{
            Path:     c.Request.URL.Path,
            Method:   c.Request.Method,
            Count:    0,
            LastSeen: time.Now(),
        }
        ad.requestPatterns[key] = pattern
    }

    // 检查是否被封禁
    if time.Now().Before(pattern.BlockedUntil) {
        return false
    }

    pattern.Count++
    pattern.LastSeen = time.Now()

    // 检测异常模式
    if ad.isAnomalous(pattern) {
        pattern.BlockedUntil = time.Now().Add(time.Hour)
        ad.alertChan <- &Alert{
            Type:    "anomalous_traffic",
            Message: fmt.Sprintf("异常请求模式: %s", key),
            Details: map[string]interface{}{
                "ip":        ip,
                "path":      pattern.Path,
                "method":    pattern.Method,
                "count":     pattern.Count,
            },
        }
        return false
    }

    return true
}
```

#### SQL注入检测
```go
type SQLInjectionDetector struct {
    patterns []*regexp.Regexp
}

func NewSQLInjectionDetector() *SQLInjectionDetector {
    patterns := []*regexp.Regexp{
        regexp.MustCompile(`(?i)\b(union|select|insert|update|delete|drop|create|alter)\b.*\b(select|from|where|group|order|having|limit)\b`),
        regexp.MustCompile(`(?i)['";\\-]+\s*(or|and)\s*['"]*\d+['"]*\s*[=><]`),
        regexp.MustCompile(`(?i)(--|#|/\*|\*/)`),
    }

    return &SQLInjectionDetector{patterns: patterns}
}

func (sid *SQLInjectionDetector) Detect(input string) bool {
    for _, pattern := range sid.patterns {
        if pattern.MatchString(input) {
            return true
        }
    }
    return false
}
```

### 安全告警系统

#### 实时告警
```go
type AlertManager struct {
    alerts   chan *Alert
    handlers []AlertHandler
}

type Alert struct {
    ID          string                 `json:"id"`
    Type        string                 `json:"type"`
    Severity    string                 `json:"severity"`
    Title       string                 `json:"title"`
    Message     string                 `json:"message"`
    Timestamp   time.Time              `json:"timestamp"`
    Source      string                 `json:"source"`
    Details     map[string]interface{} `json:"details"`
    Resolved    bool                   `json:"resolved"`
    ResolvedAt  *time.Time             `json:"resolved_at,omitempty"`
}

type AlertHandler interface {
    Handle(alert *Alert) error
}

func (am *AlertManager) Start() {
    go func() {
        for alert := range am.alerts {
            for _, handler := range am.handlers {
                if err := handler.Handle(alert); err != nil {
                    log.Printf("告警处理失败: %v", err)
                }
            }
        }
    }()
}

func (am *AlertManager) SendAlert(alert *Alert) {
    alert.ID = generateAlertID()
    alert.Timestamp = time.Now()

    select {
    case am.alerts <- alert:
    default:
        log.Printf("告警队列满，丢弃告警: %s", alert.Title)
    }
}
```

#### 告警处理器
```go
// 邮件告警处理器
type EmailAlertHandler struct {
    smtpClient *smtp.Client
    recipients []string
}

func (eah *EmailAlertHandler) Handle(alert *Alert) error {
    subject := fmt.Sprintf("[%s] %s", strings.ToUpper(alert.Severity), alert.Title)

    body := fmt.Sprintf(`
安全告警通知

类型: %s
级别: %s
时间: %s
来源: %s
消息: %s

详情: %v
    `, alert.Type, alert.Severity, alert.Timestamp.Format(time.RFC3339),
        alert.Source, alert.Message, alert.Details)

    return eah.sendEmail(subject, body)
}

// Slack告警处理器
type SlackAlertHandler struct {
    webhookURL string
    client     *http.Client
}

func (sah *SlackAlertHandler) Handle(alert *Alert) error {
    payload := map[string]interface{}{
        "text": fmt.Sprintf("*安全告警* [%s] %s", strings.ToUpper(alert.Severity), alert.Title),
        "attachments": []map[string]interface{}{
            {
                "color": sah.getColorBySeverity(alert.Severity),
                "fields": []map[string]interface{}{
                    {"title": "类型", "value": alert.Type, "short": true},
                    {"title": "时间", "value": alert.Timestamp.Format(time.RFC3339), "short": true},
                    {"title": "来源", "value": alert.Source, "short": true},
                    {"title": "消息", "value": alert.Message, "short": false},
                },
            },
        },
    }

    return sah.sendToSlack(payload)
}
```

## 安全配置

### 应用安全配置

#### HTTP安全头
```go
func SecurityHeadersMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 防止点击劫持
        c.Header("X-Frame-Options", "DENY")

        // 防止MIME类型嗅探
        c.Header("X-Content-Type-Options", "nosniff")

        // XSS保护
        c.Header("X-XSS-Protection", "1; mode=block")

        // HSTS (HTTP Strict Transport Security)
        c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains")

        // CSP (Content Security Policy)
        c.Header("Content-Security-Policy", "default-src 'self'; script-src 'self' 'unsafe-inline'")

        // Referrer Policy
        c.Header("Referrer-Policy", "strict-origin-when-cross-origin")

        c.Next()
    }
}
```

#### CORS配置
```go
func CORSConfig() gin.HandlerFunc {
    return cors.New(cors.Config{
        AllowOrigins:     []string{"https://trusted-domain.com"},
        AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
        AllowHeaders:     []string{"Origin", "Content-Type", "Authorization"},
        ExposeHeaders:    []string{"Content-Length"},
        AllowCredentials: true,
        MaxAge:           12 * time.Hour,
    })
}
```

### 数据库安全配置

#### SQL注入防护
```go
// 参数化查询
func (dao *UserDAO) GetUserByID(ctx context.Context, userID int64) (*User, error) {
    query := "SELECT id, username, email FROM users WHERE id = ?"
    row := dao.db.QueryRowContext(ctx, query, userID)

    var user User
    err := row.Scan(&user.ID, &user.Username, &user.Email)
    return &user, err
}

// 使用预编译语句
func (dao *UserDAO) InsertUser(ctx context.Context, user *User) error {
    stmt, err := dao.db.PrepareContext(ctx,
        "INSERT INTO users (username, email, created_at) VALUES (?, ?, ?)")
    if err != nil {
        return err
    }
    defer stmt.Close()

    _, err = stmt.ExecContext(ctx, user.Username, user.Email, time.Now())
    return err
}
```

#### 数据库权限控制
```sql
-- 创建应用专用用户
CREATE USER 'app_user'@'localhost' IDENTIFIED BY 'StrongPassword123!';

-- 授予最小权限
GRANT SELECT, INSERT, UPDATE, DELETE ON myapp.* TO 'app_user'@'localhost';
GRANT EXECUTE ON PROCEDURE myapp.* TO 'app_user'@'localhost';

-- 禁用远程root登录
DELETE FROM mysql.user WHERE User='root' AND Host NOT IN ('localhost', '127.0.0.1', '::1');

-- 设置密码策略
SET GLOBAL validate_password_policy = 2;
SET GLOBAL validate_password_length = 12;
SET GLOBAL validate_password_mixed_case_count = 1;
SET GLOBAL validate_password_number_count = 1;
SET GLOBAL validate_password_special_char_count = 1;
```

## 安全测试

### 渗透测试清单

#### 身份认证测试
- [ ] 弱密码测试
- [ ] 暴力破解防护
- [ ] 会话管理测试
- [ ] JWT令牌测试

#### 授权测试
- [ ] 水平权限提升
- [ ] 垂直权限提升
- [ ] 直接对象引用
- [ ] 功能级访问控制

#### 输入验证测试
- [ ] SQL注入测试
- [ ] XSS测试
- [ ] CSRF测试
- [ ] 命令注入测试

#### 传输安全测试
- [ ] SSL/TLS配置测试
- [ ] 证书有效性测试
- [ ] 加密强度测试
- [ ] 中间人攻击防护

### 自动化安全测试

#### 单元测试安全检查
```go
func TestSQLInjectionPrevention(t *testing.T) {
    maliciousInputs := []string{
        "'; DROP TABLE users; --",
        "' OR '1'='1",
        "<script>alert('xss')</script>",
        "../../../etc/passwd",
    }

    for _, input := range maliciousInputs {
        if !isInputSafe(input) {
            t.Errorf("不安全的输入未被正确过滤: %s", input)
        }
    }
}

func TestPasswordHashing(t *testing.T) {
    password := "testpassword123"

    hash1, err := hashPassword(password)
    if err != nil {
        t.Fatal(err)
    }

    hash2, err := hashPassword(password)
    if err != nil {
        t.Fatal(err)
    }

    // 确保每次哈希结果不同 (盐值)
    if hash1 == hash2 {
        t.Error("密码哈希应该使用随机盐值")
    }

    // 确保能正确验证
    if !verifyPassword(password, hash1) {
        t.Error("密码验证失败")
    }
}
```

#### 集成测试安全场景
```go
func TestRateLimiting(t *testing.T) {
    // 模拟高频请求
    for i := 0; i < 100; i++ {
        resp, err := http.Get("http://localhost:8080/api/users")
        if err != nil {
            t.Fatal(err)
        }

        if i > 50 && resp.StatusCode != 429 {
            t.Errorf("期望429状态码，得到%d", resp.StatusCode)
        }
        resp.Body.Close()
    }
}

func TestAuthentication(t *testing.T) {
    // 测试无认证请求
    resp, err := http.Get("http://localhost:8080/api/admin/users")
    if err != nil {
        t.Fatal(err)
    }

    if resp.StatusCode != 401 {
        t.Errorf("期望401状态码，得到%d", resp.StatusCode)
    }
    resp.Body.Close()

    // 测试有效认证
    req, _ := http.NewRequest("GET", "http://localhost:8080/api/admin/users", nil)
    req.Header.Set("Authorization", "Bearer "+validToken)

    resp, err = http.DefaultClient.Do(req)
    if err != nil {
        t.Fatal(err)
    }

    if resp.StatusCode != 200 {
        t.Errorf("期望200状态码，得到%d", resp.StatusCode)
    }
    resp.Body.Close()
}
```

## 安全事件响应

### 事件响应流程

#### 1. 事件检测
- 实时监控安全日志
- 异常行为自动检测
- 用户报告处理

#### 2. 事件评估
```go
type IncidentResponse struct {
    incidentID   string
    severity     IncidentSeverity
    status       IncidentStatus
    assignee     string
    createdAt    time.Time
    updatedAt    time.Time
    description  string
    affectedSystems []string
    actions       []IncidentAction
}

func (ir *IncidentResponse) AssessSeverity() IncidentSeverity {
    // 基于影响范围和严重程度评估
    if ir.containsDataBreach() {
        return SeverityCritical
    }
    if ir.affectsAvailability() {
        return SeverityHigh
    }
    return SeverityMedium
}
```

#### 3. 响应措施
- **立即响应**: 隔离受影响系统
- **调查分析**: 收集证据和日志
- **修复措施**: 部署补丁和配置更改
- **预防措施**: 更新安全策略和监控

#### 4. 后续处理
- **文档记录**: 详细记录事件经过
- **经验总结**: 分析根本原因
- **改进措施**: 更新安全策略和流程

## 总结

数据中间件的安全设计涵盖：

1. **传输安全**: TLS 1.3加密、证书管理、双向认证
2. **数据安全**: 字段级加密、密钥轮换、HSM集成
3. **访问控制**: JWT认证、RBAC权限、频率限制
4. **安全监控**: 审计日志、入侵检测、实时告警
5. **安全配置**: HTTP安全头、CORS配置、数据库权限
6. **安全测试**: 渗透测试、自动化安全测试

通过多层次的安全防护，确保系统在高并发场景下的安全性和合规性。
