# 数据库设计规范

## 概述

数据中间件支持Oracle到MySQL的平滑迁移，采用多数据库实例架构，支持按游戏分库的扩展模式。

## 核心需求分析

1. **数据库切换**: Oracle (前期) → MySQL (后期) 平滑切换
2. **多游戏支持**: 每个游戏独立数据库实例
3. **高并发优化**: 连接池、分表、读写分离
4. **数据一致性**: 事务管理、数据同步
5. **扩展性**: 支持水平扩展和垂直拆分

## 数据库架构设计

### 单机部署架构
```
┌─────────────────────────────────────────────────────────────┐
│                    Application Server                       │
│  ┌─────────────────┬─────────────────┬─────────────────┐     │
│  │   Game Router   │ Connection Pool │   Data Access    │     │
│  │   (游戏路由)     │   (连接池管理)   │   (数据访问层)    │     │
│  └─────────────────┴─────────────────┴─────────────────┘     │
└─────────────────────┬───────────────────────────────────────┘
                      │
           ┌──────────┼──────────┐
           │          │          │
    ┌──────▼────┐ ┌───▼────┐ ┌───▼────┐
    │  Oracle   │ │ MySQL  │ │ Redis  │
    │  (Legacy) │ │ (New)  │ │ (Cache)│
    └───────────┘ └────────┘ └────────┘
```

### 集群部署架构
```
┌─────────────────────────────────────────────────────────────┐
│                    Load Balancer                            │
└─────────────────────┬───────────────────────────────────────┘
                      │
        ┌─────────────┼─────────────┐
        │             │             │
┌───────▼─────┐ ┌─────▼──────┐ ┌────▼──────┐
│ App Server  │ │ App Server  │ │ App Server  │
│  Instance1  │ │  Instance2  │ │  Instance3  │
└───────┬─────┘ └─────┬──────┘ └────┬───────┘
        │             │             │
        └─────────────┼─────────────┘
                      │
        ┌─────────────┼─────────────┐
        │             │             │
┌───────▼─────┐ ┌─────▼──────┐ ┌────▼──────┐
│ Database    │ │ Database    │ │ Redis      │
│ Cluster     │ │ Cluster     │ │ Cluster    │
│ (Oracle)    │ │ (MySQL)     │ │ (Cache)    │
└─────────────┘ └─────────────┘ └────────────┘
```

## 业务实体设计

### 核心业务实体 (高并发优化设计)

1. **玩家 (Player)**: 玩家基本信息、状态、等级等
   - **高频访问**: 登录、查询、更新操作频繁
   - **缓存策略**: L1缓存 10分钟，L2缓存 1小时
   - **索引优化**: 用户名、状态复合索引

2. **角色 (Character)**: 游戏角色信息、属性、装备等
   - **游戏内操作**: 角色切换、属性更新频繁
   - **缓存策略**: L1缓存 5分钟，L2缓存 30分钟
   - **关联优化**: 与Player的一对多关系预加载

3. **道具 (Item)**: 游戏道具信息、数量、属性等
   - **交易频繁**: 使用、转移、交易操作密集
   - **缓存策略**: L1缓存 3分钟，L2缓存 15分钟
   - **热点数据**: 热门道具常驻缓存

4. **订单 (Order)**: 充值订单、交易记录等
   - **写多读少**: 创建和更新操作为主
   - **异步处理**: 非实时性，适合异步写入
   - **归档策略**: 历史订单定期归档

5. **鉴权令牌 (AuthToken)**: 用户认证信息
   - **会话管理**: 登录状态、权限验证
   - **缓存策略**: L1缓存 30分钟，L2缓存 2小时
   - **安全考虑**: Token黑名单机制

### 实体关系设计 (高并发优化)

```
Player (1) ──── (N) Character [缓存关系，预加载]
   │
   ├── (N) Item (背包道具) [热点数据缓存，LRU淘汰]
   │
   └── (N) Order (订单记录) [异步写入，批量处理]
```

### 数据访问模式分析

#### 读写比例评估
- **Player**: 读:写 = 80:20 (查询为主)
- **Character**: 读:写 = 70:30 (游戏内操作)
- **Item**: 读:写 = 60:40 (频繁交易)
- **Order**: 读:写 = 20:80 (创建和更新为主)

#### 缓存策略配置
```yaml
cache:
  entities:
    player:
      l1_ttl: 10m
      l2_ttl: 1h
      strategy: "write_through"
    character:
      l1_ttl: 5m
      l2_ttl: 30m
      strategy: "write_back"
    item:
      l1_ttl: 3m
      l2_ttl: 15m
      strategy: "write_around"
    order:
      l1_ttl: 1m
      l2_ttl: 5m
      strategy: "write_behind"
```

## 数据模型设计

### Player 玩家表
```sql
CREATE TABLE players (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100),
    password_hash VARCHAR(255) NOT NULL,
    level INT DEFAULT 1,
    exp BIGINT DEFAULT 0,
    gold BIGINT DEFAULT 0,
    status TINYINT DEFAULT 1, -- 0:禁用, 1:正常, 2:冻结
    last_login_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    INDEX idx_username (username),
    INDEX idx_status (status),
    INDEX idx_last_login (last_login_at),
    INDEX idx_level_exp (level, exp)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### Character 角色表
```sql
CREATE TABLE characters (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    player_id BIGINT NOT NULL,
    name VARCHAR(50) NOT NULL,
    class_type TINYINT NOT NULL, -- 职业类型
    level INT DEFAULT 1,
    exp BIGINT DEFAULT 0,
    hp INT DEFAULT 100,
    mp INT DEFAULT 100,
    strength INT DEFAULT 10,
    agility INT DEFAULT 10,
    intelligence INT DEFAULT 10,
    equipment JSON, -- 装备信息
    status TINYINT DEFAULT 1,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (player_id) REFERENCES players(id) ON DELETE CASCADE,
    INDEX idx_player_id (player_id),
    INDEX idx_class_level (class_type, level),
    INDEX idx_status (status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### Item 道具表
```sql
CREATE TABLE items (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    player_id BIGINT NOT NULL,
    item_id INT NOT NULL, -- 道具配置ID
    name VARCHAR(100) NOT NULL,
    description TEXT,
    quantity INT DEFAULT 1,
    quality TINYINT DEFAULT 1, -- 1:普通, 2:优秀, 3:稀有, 4:史诗, 5:传说
    durability INT, -- 耐久度
    attributes JSON, -- 附加属性
    acquired_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP NULL, -- 过期时间

    FOREIGN KEY (player_id) REFERENCES players(id) ON DELETE CASCADE,
    INDEX idx_player_id (player_id),
    INDEX idx_item_id (item_id),
    INDEX idx_quality (quality),
    INDEX idx_expires (expires_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### Order 订单表
```sql
CREATE TABLE orders (
    id VARCHAR(50) PRIMARY KEY, -- 全局唯一订单号
    player_id BIGINT NOT NULL,
    order_type TINYINT NOT NULL, -- 1:充值, 2:道具购买, 3:道具出售
    item_id INT,
    quantity INT DEFAULT 1,
    unit_price DECIMAL(10,2),
    total_amount DECIMAL(10,2) NOT NULL,
    currency VARCHAR(10) DEFAULT 'gold',
    status TINYINT DEFAULT 1, -- 1:待支付, 2:已支付, 3:已取消, 4:已完成
    payment_method VARCHAR(20),
    payment_at TIMESTAMP NULL,
    completed_at TIMESTAMP NULL,
    notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (player_id) REFERENCES players(id) ON DELETE CASCADE,
    INDEX idx_player_id (player_id),
    INDEX idx_status (status),
    INDEX idx_created (created_at),
    INDEX idx_payment (payment_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

## 索引优化策略

### 复合索引设计
```sql
-- 玩家查询优化
CREATE INDEX idx_player_status_level ON players (status, level);
CREATE INDEX idx_player_login_time ON players (last_login_at, status);

-- 角色查询优化
CREATE INDEX idx_character_player_class ON characters (player_id, class_type, level);

-- 道具查询优化
CREATE INDEX idx_item_player_quality ON items (player_id, quality, item_id);
CREATE INDEX idx_item_expiry ON items (expires_at, player_id);

-- 订单查询优化
CREATE INDEX idx_order_player_status ON orders (player_id, status, created_at);
CREATE INDEX idx_order_time_range ON orders (created_at, status);
```

### 索引覆盖优化
```sql
-- 玩家列表查询 (索引覆盖)
CREATE INDEX idx_player_list ON players (status, level, exp, last_login_at, username);

-- 角色属性查询 (索引覆盖)
CREATE INDEX idx_character_attrs ON characters (player_id, level, hp, mp, strength);

-- 道具背包查询 (索引覆盖)
CREATE INDEX idx_item_inventory ON items (player_id, item_id, quantity, quality);
```

## 分库分表策略

### 按游戏分库
```
game1_database/
├── players
├── characters
├── items
├── orders
└── ...

game2_database/
├── players
├── characters
├── items
├── orders
└── ...
```

### 水平分表策略
```sql
-- 玩家表水平分表 (按ID哈希)
CREATE TABLE players_00 LIKE players;
CREATE TABLE players_01 LIKE players;
-- ...
CREATE TABLE players_99 LIKE players;

-- 分表路由规则
player_id % 100 → players_{XX}
```

### 分表查询中间件
```go
type ShardingRouter struct {
    tableCount int
    dbSelector func(entityID int64) string
}

func (r *ShardingRouter) GetTableName(entityID int64) string {
    shard := entityID % int64(r.tableCount)
    return fmt.Sprintf("players_%02d", shard)
}
```

## 读写分离配置

### 主从复制架构
```sql
-- 主库配置 (写操作)
master:
  host: "master-db"
  port: 3306
  role: "write"

-- 从库配置 (读操作)
slaves:
  - host: "slave-db-01"
    port: 3306
    role: "read"
    weight: 1
  - host: "slave-db-02"
    port: 3306
    role: "read"
    weight: 1
```

### 读写分离中间件
```go
type ReadWriteSplitter struct {
    master *sql.DB
    slaves []*sql.DB
    strategy BalanceStrategy
}

func (rws *ReadWriteSplitter) Query(query string, args ...interface{}) (*sql.Rows, error) {
    // 读操作路由到从库
    slave := rws.strategy.SelectSlave(rws.slaves)
    return slave.Query(query, args...)
}

func (rws *ReadWriteSplitter) Exec(query string, args ...interface{}) (sql.Result, error) {
    // 写操作路由到主库
    return rws.master.Exec(query, args...)
}
```

## 连接池深度优化

### 高级连接池配置
```yaml
database:
  pools:
    # 主库连接池 (写操作)
    master:
      max_open_conns: 100      # 最大连接数
      max_idle_conns: 20       # 最大空闲连接
      conn_max_lifetime: 1h    # 连接最大生命周期
      conn_max_idle_time: 30m  # 空闲连接最大时间

    # 从库连接池 (读操作)
    slaves:
      - max_open_conns: 200    # 从库可承受更高并发
        max_idle_conns: 50
        conn_max_lifetime: 2h
        conn_max_idle_time: 1h
        weight: 1              # 负载均衡权重
```

### 连接池监控
```go
type ConnectionPoolMonitor struct {
    pools map[string]*PoolStats
}

type PoolStats struct {
    ActiveConnections int64
    IdleConnections   int64
    TotalConnections  int64
    WaitCount         int64
    WaitDuration      time.Duration
}

func (cpm *ConnectionPoolMonitor) CollectStats() {
    for name, pool := range cpm.pools {
        stats := pool.Stats()
        // 记录监控指标
        metrics.RecordPoolStats(name, stats)
    }
}
```

## 数据迁移策略

### Oracle到MySQL迁移

#### 1. 模式迁移
```sql
-- 创建MySQL表结构
-- 字段类型映射
Oracle: NUMBER(10)    → MySQL: INT
Oracle: VARCHAR2(100) → MySQL: VARCHAR(100)
Oracle: CLOB         → MySQL: TEXT
Oracle: BLOB         → MySQL: LONGBLOB
Oracle: TIMESTAMP    → MySQL: TIMESTAMP
```

#### 2. 数据迁移脚本
```bash
#!/bin/bash
# 数据迁移脚本

# 导出Oracle数据
expdp system/password schemas=GAME1 directory=DATA_PUMP_DIR dumpfile=game1.dmp

# 转换数据格式
# 使用工具如: ora2pg, mysql-migration-tools

# 导入MySQL数据
mysql -u root -p game1 < game1_mysql.sql
```

#### 3. 增量同步
```sql
-- 使用binlog进行增量同步
-- 配置MySQL binlog
log-bin=mysql-bin
binlog-format=ROW
server-id=2

-- 使用工具如: canal, debezium进行实时同步
```

### 零停机迁移方案

#### 双写策略
```go
type DualWriter struct {
    oracle *OracleDAO
    mysql  *MySQLDAO
    logger logger.Logger
}

func (dw *DualWriter) Write(entity interface{}) error {
    // 同时写入两个数据库
    err1 := dw.oracle.Insert(entity)
    err2 := dw.mysql.Insert(entity)

    if err1 != nil || err2 != nil {
        dw.logger.Error("双写失败", "oracle_err", err1, "mysql_err", err2)
        return errors.New("双写失败")
    }

    return nil
}
```

#### 灰度切换
```yaml
# 配置灰度比例
migration:
  oracle_ratio: 30  # 30%请求仍使用Oracle
  mysql_ratio: 70   # 70%请求使用MySQL
  enable_shadow: true # 开启影子表验证
```

## 备份和恢复策略

### 多级备份策略
```bash
#!/bin/bash
# 多级备份脚本

# 1. 全量备份 (每周)
mysqldump --all-databases > full_backup_$(date +%Y%m%d).sql.gz

# 2. 增量备份 (每日)
mysqlbackup --backup-dir=/backup/incremental \
           --incremental \
           --incremental-base-dir=/backup/base

# 3. 异地备份 (实时)
# 使用工具如: rsync, DRBD进行异地同步
```

### 备份验证
```bash
# 备份文件完整性检查
gzip -t backup.sql.gz

# 备份数据一致性检查
mysql -e "CHECKSUM TABLE users, orders, items;"

# 恢复测试
mysql < backup.sql
# 运行测试用例验证数据完整性
```

## 性能监控和调优

### 数据库指标监控
```yaml
monitoring:
  database:
    # 连接池指标
    - pool_active_connections
    - pool_idle_connections
    - pool_wait_count
    - pool_wait_duration

    # 查询性能指标
    - query_execution_time
    - slow_query_count
    - deadlock_count

    # 存储指标
    - table_size
    - index_size
    - disk_usage

    # 缓存指标
    - cache_hit_ratio
    - buffer_pool_usage
```

### 慢查询分析
```sql
-- 启用慢查询日志
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1; -- 1秒以上记录

-- 分析慢查询
SELECT sql_text, exec_count, avg_timer_wait/1000000000 avg_sec
FROM performance_schema.events_statements_summary_by_digest
ORDER BY avg_timer_wait DESC
LIMIT 10;
```

### 索引优化建议
```sql
-- 查看未使用索引
SELECT object_schema, object_name, index_name
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE index_name IS NOT NULL
AND count_star = 0;

-- 查看冗余索引
SELECT table_name, index_name, column_name, seq_in_index
FROM information_schema.statistics
WHERE table_schema = 'your_database'
ORDER BY table_name, index_name, seq_in_index;
```

## 扩展性设计

### 水平扩展准备
```yaml
scaling:
  # 数据分片配置
  sharding:
    players: 100  # 玩家表分100个片
    orders: 200   # 订单表分200个片
    items: 50     # 道具表分50个片

  # 读写分离配置
  replication:
    masters: 1
    slaves: 3
    load_balance: "round_robin"
```

### 垂直拆分策略
```sql
-- 冷热数据分离
CREATE TABLE players_hot LIKE players;     -- 活跃玩家
CREATE TABLE players_warm LIKE players;    -- 一般玩家
CREATE TABLE players_cold LIKE players;    -- 不活跃玩家

-- 历史数据归档
CREATE TABLE orders_2024 LIKE orders;
CREATE TABLE orders_2023 LIKE orders;
```

## 容灾和高可用

### 主从切换
```bash
#!/bin/bash
# 主从切换脚本

# 1. 检查从库状态
mysql -h slave -e "SHOW SLAVE STATUS\G"

# 2. 停止从库复制
mysql -h slave -e "STOP SLAVE;"

# 3. 提升从库为主库
mysql -h slave -e "RESET MASTER;"

# 4. 更新应用配置指向新主库
# 5. 重启从库指向新主库
```

### 数据校验和修复
```sql
-- 数据一致性检查
CHECKSUM TABLE players, orders, items;

-- 修复数据不一致
REPAIR TABLE corrupted_table;

-- 使用pt-table-checksum进行跨库校验
pt-table-checksum --replicate=percona.checksums h=localhost
```

## 安全加固

### 数据库安全配置
```sql
-- 禁用远程root登录
DELETE FROM mysql.user WHERE User='root' AND Host NOT IN ('localhost', '127.0.0.1');

-- 设置强密码策略
SET GLOBAL validate_password_policy = 2;
SET GLOBAL validate_password_length = 12;

-- 启用审计日志
SET GLOBAL audit_log_policy = 'ALL';
```

### 访问控制
```sql
-- 创建应用专用用户
CREATE USER 'app_user'@'localhost' IDENTIFIED BY 'StrongPassword123!';
GRANT SELECT, INSERT, UPDATE, DELETE ON game1.* TO 'app_user'@'localhost';

-- 启用行级安全 (MySQL 8.0+)
CREATE TABLE players WITH SYSTEM VERSIONING;
```

### 加密和脱敏
```sql
-- 字段级加密
CREATE TABLE sensitive_data (
    id INT PRIMARY KEY,
    encrypted_ssn VARBINARY(255),
    key_id INT
);

-- 数据脱敏函数
CREATE FUNCTION mask_email(email VARCHAR(255))
RETURNS VARCHAR(255)
DETERMINISTIC
RETURN CONCAT(LEFT(email, 3), '***', SUBSTRING(email, LOCATE('@', email)));
```

## 总结

数据库设计遵循以下原则：

1. **高并发优化**: 连接池、分表、读写分离
2. **扩展性保障**: 分库分表、水平扩展准备
3. **数据一致性**: 事务管理、数据校验
4. **性能监控**: 慢查询分析、指标收集
5. **安全合规**: 访问控制、数据加密
6. **运维友好**: 备份恢复、容灾高可用

通过这套设计，可以支持从单机到大规模集群的平滑扩展，保证数据的高性能、高可用和高安全。
